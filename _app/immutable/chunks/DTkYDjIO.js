var da=Object.defineProperty;var ua=(l,a,t)=>a in l?da(l,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[a]=t;var Is=(l,a,t)=>ua(l,typeof a!="symbol"?a+"":a,t);import{j as la,t as q,s as E,a as H,e as ra}from"./wHeHpe8M.js";import"./DPOUz0k3.js";import{av as va,y as ya,Q as oa,X as fa,R as aa,h as pa,aw as ga,p as Qs,c as i,r as n,t as ts,g as s,u as I,s as e,a as Xs,D as F,a4 as qs,ad as ba,E as h,n as Q,f as ka}from"./C93sEKZr.js";import{h as x}from"./CCGrtHmb.js";import{p as X,i as Ps}from"./TDdWhIBO.js";import{e as Rs,i as Ns,f as Ws,r as es,s as ea}from"./yTH5Laox.js";function Fs(l,a,t=a){var r=va();la(l,"input",o=>{var d=o?l.defaultValue:l.value;if(d=Ks(l)?Vs(d):d,t(d),r&&d!==(d=a())){var c=l.selectionStart,m=l.selectionEnd;l.value=d??"",m!==null&&(l.selectionStart=c,l.selectionEnd=Math.min(m,l.value.length))}}),(pa&&l.defaultValue!==l.value||ya(a)==null&&l.value)&&t(Ks(l)?Vs(l.value):l.value),oa(()=>{var o=a();Ks(l)&&o===Vs(l.value)||l.type==="date"&&!o&&!l.value||o!==l.value&&(l.value=o??"")})}const Ys=new Set;function ta(l,a,t,r,o=r){var d=t.getAttribute("type")==="checkbox",c=l;let m=!1;if(a!==null)for(var u of a)c=c[u]??(c[u]=[]);c.push(t),la(t,"change",()=>{var p=t.__value;d&&(p=na(c,p,t.checked)),o(p)},()=>o(d?[]:null)),oa(()=>{var p=r();if(pa&&t.defaultChecked!==t.checked){m=!0;return}d?(p=p||[],t.checked=p.includes(t.__value)):t.checked=ga(t.__value,p)}),fa(()=>{var p=c.indexOf(t);p!==-1&&c.splice(p,1)}),Ys.has(c)||(Ys.add(c),aa(()=>{c.sort((p,k)=>p.compareDocumentPosition(k)===4?-1:1),Ys.delete(c)})),aa(()=>{if(m){var p;if(d)p=na(c,p,t.checked);else{var k=c.find(w=>w.checked);p=k==null?void 0:k.__value}o(p)}})}function na(l,a,t){for(var r=new Set,o=0;o<l.length;o+=1)l[o].checked&&r.add(l[o].__value);return t||r.delete(a),Array.from(r)}function Ks(l){var a=l.type;return a==="number"||a==="range"}function Vs(l){return l===""?null:+l}const wa=16,xa=4;function Os(l,a){let t=5381;for(let r=0;r<l.length;r++)t=(t<<5)+t+l.charCodeAt(r)>>>0;return t%a}function Ls(l,a){let t=0;for(let o=0;o<l.length;o++)t=l.charCodeAt(o)+(t<<6)+(t<<16)-t>>>0;let r=t%a;return r===0&&(r=1),a%2===0&&r%2===0&&(r=r===a-1?1:r+1),r}function Ea(l,a){return(l%a+a)%a}function _s(l,a,t){if(!l||a<=0||t<=0)return[];const r=Os(l,a),o=Ls(l,a),d=[];for(let c=0;c<t;c++){const m=Ea(r+c*o,a);d.push(m)}return d.sort((c,m)=>c-m)}class _a{constructor(a,t){Is(this,"bitArray");Is(this,"size");Is(this,"numHashFunctions");this.size=a,this.numHashFunctions=t,this.bitArray=new Array(a).fill(!1)}generateInsertSteps(a){const t=[],r=Os(a,this.size),o=Ls(a,this.size);t.push({type:"hash1",value:r}),t.push({type:"hash2",value:o});const d=_s(a,this.size,this.numHashFunctions),c=new Array(this.size).fill("0");return d.forEach(m=>c[m]="1"),t.push({type:"binary",value:c.join("")}),d.forEach(m=>{const u=this.bitArray[m];t.push({type:"setBit",index:m,wasSet:u})}),t}generateCheckSteps(a){const t=[],r=Os(a,this.size),o=Ls(a,this.size);t.push({type:"hash1",value:r}),t.push({type:"hash2",value:o});const d=_s(a,this.size,this.numHashFunctions),c=new Array(this.size).fill("0");return d.forEach(m=>c[m]="1"),t.push({type:"binary",value:c.join("")}),d.forEach(m=>{t.push({type:"setBit",index:m,wasSet:this.bitArray[m]})}),t}insert(a){_s(a,this.size,this.numHashFunctions).forEach(r=>{this.bitArray[r]=!0})}check(a){return _s(a,this.size,this.numHashFunctions).every(r=>this.bitArray[r])}getBitArray(){return[...this.bitArray]}reset(){this.bitArray.fill(!1)}getHashValues(a){return{h1:Os(a,this.size),h2:Ls(a,this.size)}}getBinaryRepresentation(a){const t=_s(a,this.size,this.numHashFunctions),r=new Array(this.size).fill("0");return t.forEach(o=>r[o]="1"),r.join("")}getSize(){return this.size}}var Fa=q("<div> </div>"),Ba=q('<span class="index svelte-rx78hf"> </span>'),za=q('<div class="bit-segment svelte-rx78hf"><div class="segment-bits svelte-rx78hf"></div> <div class="segment-indices svelte-rx78hf"></div></div>');function ia(l,a){Qs(a,!0);const t=X(a,"type",3,"bitarray"),r=X(a,"highlightedBits",19,()=>new Set),o=X(a,"bitColors",19,()=>new Map);var d=za(),c=i(d);Rs(c,21,()=>a.bits,Ns,(u,p,k)=>{var w=Fa();const _=I(()=>a.startIndex+k);let B;var D=i(w,!0);n(w),ts(M=>{B=Ws(w,1,"bit svelte-rx78hf",null,B,M),E(D,t()==="binary"?s(p):s(p)?"1":"0")},[()=>({active:t()==="binary"&&s(p)==="1",set:t()==="bitarray"&&s(p)===!0,highlighted:r().has(s(_)),blue:o().get(s(_))==="blue",red:o().get(s(_))==="red"})]),H(u,w)}),n(c);var m=e(c,2);Rs(m,21,()=>a.bits,Ns,(u,p,k)=>{var w=Ba();const _=I(()=>a.startIndex+k);var B=i(w,!0);n(w),ts(()=>E(B,s(_))),H(u,w)}),n(m),n(d),H(l,d),Xs()}async function Da(l,a,t,r){a()&&(await t("check",s(r)),h(r,""))}var Aa=q('<div class="binary-grid svelte-1j0um23"></div>'),Ta=q('<div class="binary-placeholder svelte-1j0um23"><span class="placeholder svelte-1j0um23">— Nothing yet —</span></div>'),Ca=(l,a)=>l.key==="Enter"&&a(),Ma=q('<div class="input-section svelte-1j0um23"><input type="text" placeholder="Enter a string..." class="svelte-1j0um23"> <div class="button-group svelte-1j0um23"><button type="button" class="insert-btn svelte-1j0um23">Insert</button> <button type="button" class="check-btn svelte-1j0um23">Check</button> <button type="button" class="reset-btn svelte-1j0um23">Reset</button></div></div>'),Sa=q('<div class="result-display svelte-1j0um23"><span class="operation svelte-1j0um23"> </span> <span> </span></div>'),ja=q('<div class="bloom-filter-container svelte-1j0um23"><div class="layout svelte-1j0um23"><div class="main-content svelte-1j0um23"><div class="hash-display svelte-1j0um23"><div class="hash-item svelte-1j0um23"><label class="svelte-1j0um23">Hash 1:</label> <span> </span></div> <div class="hash-item svelte-1j0um23"><label class="svelte-1j0um23">Hash 2:</label> <span> </span></div></div> <div class="binary-display svelte-1j0um23"><label class="svelte-1j0um23">Mapped Bits:</label> <!></div> <!> <!> <div class="binary-display svelte-1j0um23"><label class="svelte-1j0um23">Bit Array:</label> <div class="binary-grid svelte-1j0um23"></div></div></div> <div class="parameters-column svelte-1j0um23"><div class="parameters-section svelte-1j0um23"><h3 class="svelte-1j0um23">Parameters</h3> <div class="parameter-item svelte-1j0um23"><label class="svelte-1j0um23">k (Hash Functions):</label> <span class="parameter-value svelte-1j0um23"> </span></div> <div class="parameter-item svelte-1j0um23"><label class="svelte-1j0um23">m (Bit Array Size):</label> <span class="parameter-value svelte-1j0um23"> </span></div></div></div></div></div>');function Ha(l,a){Qs(a,!0);const t=X(a,"size",3,wa),r=X(a,"numHashFunctions",3,xa),o=X(a,"stepDuration",3,1500),d=X(a,"userInputEnabled",3,!0),c=X(a,"autoAnimate",3,!0);let m,u=F(""),p=F(!1),k=F(-1),w=F(qs([])),_=F(null),B=F(null),D=F(null),M=F(null),O=F(""),T=F(qs([])),C=F(qs(new Set)),z=F(qs(new Map));ba(()=>{m=new _a(t(),r()),h(T,m.getBitArray(),!0)});const Z=I(r),L=I(t);function J(){h(D,null),h(M,null),h(O,""),s(C).clear(),s(z).clear(),h(B,null)}async function P(v,f){if(!(s(p)||!f.trim())){h(p,!0),h(_,v,!0),J(),v==="insert"?h(w,m.generateInsertSteps(f),!0):h(w,m.generateCheckSteps(f),!0);for(let b=0;b<s(w).length;b++){h(k,b,!0);const g=s(w)[b];switch(g.type){case"hash1":h(D,g.value,!0);break;case"hash2":h(M,g.value,!0);break;case"binary":h(O,g.value,!0);break;case"setBit":s(C).add(g.index),v==="insert"?(s(z).set(g.index,g.wasSet?"red":"blue"),g.wasSet||(s(T)[g.index]=!0)):s(z).set(g.index,g.wasSet?"blue":"red"),h(C,new Set(s(C)),!0),h(z,new Map(s(z)),!0),h(T,[...s(T)],!0);break}c()&&b<s(w).length-1&&await new Promise(A=>setTimeout(A,o()))}v==="insert"?(m.insert(f),h(B,!0)):h(B,m.check(f),!0),h(T,m.getBitArray(),!0),c()&&setTimeout(()=>{s(C).clear(),s(z).clear(),h(C,new Set,!0),h(z,new Map,!0)},o()),h(p,!1),h(k,-1)}}async function $(){d()&&(await P("insert",s(u)),h(u,""))}function R(){s(p)||(m.reset(),h(T,m.getBitArray(),!0),J())}const ns=I(()=>s(T).reduce((v,f,b)=>{const g=Math.floor(b/4);return v[g]||(v[g]=[]),v[g].push(f),v},[])),N=I(()=>s(O).split("").reduce((v,f,b)=>{const g=Math.floor(b/4);return v[g]||(v[g]=[]),v[g].push(f),v},[]));var W=ja(),U=i(W),S=i(U),Y=i(S),ss=i(Y),is=e(i(ss),2);let hs;var ds=i(is,!0);n(is),n(ss);var us=e(ss,2),vs=e(i(us),2);let ls;var Bs=i(vs,!0);n(vs),n(us),n(Y);var ys=e(Y,2),fs=e(i(ys),2);{var zs=v=>{var f=Aa();Rs(f,21,()=>s(N),Ns,(b,g,A)=>{ia(b,{get bits(){return s(g)},startIndex:A*4,type:"binary"})}),n(f),H(v,f)},Gs=v=>{var f=Ta();H(v,f)};Ps(fs,v=>{s(O)!==""?v(zs):v(Gs,!1)})}n(ys);var rs=e(ys,2);{var Ds=v=>{var f=Ma(),b=i(f);es(b),b.__keydown=[Ca,$];var g=e(b,2),A=i(g);A.__click=$;var G=e(A,2);G.__click=[Da,d,P,u];var ms=e(G,2);ms.__click=R,n(g),n(f),ts((K,js)=>{b.disabled=s(p),A.disabled=K,G.disabled=js,ms.disabled=s(p)},[()=>s(p)||!s(u).trim(),()=>s(p)||!s(u).trim()]),Fs(b,()=>s(u),K=>h(u,K)),H(v,f)};Ps(rs,v=>{d()&&v(Ds)})}var As=e(rs,2);{var gs=v=>{var f=Sa(),b=i(f),g=i(b);n(b);var A=e(b,2);let G;var ms=i(A,!0);n(A),n(f),ts(K=>{E(g,`${s(_)==="insert"?"Inserted":"Check"}:`),G=Ws(A,1,"result svelte-1j0um23",null,G,K),E(ms,s(_)==="insert"?"Element added":s(B)?"Possibly present":"Definitely not present")},[()=>({positive:s(B),negative:!s(B)})]),H(v,f)};Ps(As,v=>{s(B)!==null&&s(_)&&v(gs)})}var bs=e(As,2),Ts=e(i(bs),2);Rs(Ts,21,()=>s(ns),Ns,(v,f,b)=>{ia(v,{get bits(){return s(f)},startIndex:b*4,type:"bitarray",get highlightedBits(){return s(C)},get bitColors(){return s(z)}})}),n(Ts),n(bs),n(S);var ks=e(S,2),os=i(ks),ws=e(i(os),2),Cs=e(i(ws),2),Ms=i(Cs,!0);n(Cs),n(ws);var ps=e(ws,2),cs=e(i(ps),2),Ss=i(cs,!0);n(cs),n(ps),n(os),n(ks),n(U),n(W),ts((v,f)=>{hs=Ws(is,1,"hash-value svelte-1j0um23",null,hs,v),E(ds,s(D)??"—"),ls=Ws(vs,1,"hash-value svelte-1j0um23",null,ls,f),E(Bs,s(M)??"—"),E(Ms,s(Z)),E(Ss,s(L))},[()=>({visible:s(D)!==null}),()=>({visible:s(M)!==null})]),H(l,W),Xs()}ra(["keydown","click"]);var Ia=q('<div class="custom-params svelte-fzacrf"><div class="input-group svelte-fzacrf"><label for="custom-m" class="svelte-fzacrf">Bit Array Size (m):</label> <input id="custom-m" type="number" min="1" step="1" class="svelte-fzacrf"></div> <div class="input-group svelte-fzacrf"><label for="custom-k" class="svelte-fzacrf">Hash Functions (k):</label> <input id="custom-k" type="number" min="1" step="1" class="svelte-fzacrf"></div></div>'),qa=(l,a,t,r)=>{h(a,1e3),h(t,.01),h(r,"optimal")},Pa=(l,a,t,r)=>{h(a,1e5),h(t,.01),h(r,"optimal")},Wa=(l,a,t,r)=>{h(a,1e6),h(t,.001),h(r,"optimal")},Oa=q('<div class="calculator-container svelte-fzacrf"><h2 class="svelte-fzacrf">Bloom Filter Parameter Calculator</h2> <div class="layout svelte-fzacrf"><div class="main-content svelte-fzacrf"><div class="input-section svelte-fzacrf"><h3 class="svelte-fzacrf">Input Parameters</h3> <div class="input-group svelte-fzacrf"><label for="expected-elements" class="svelte-fzacrf">Expected Elements (n):</label> <input id="expected-elements" type="number" min="1" step="1" placeholder="100000" class="svelte-fzacrf"></div> <div class="input-group svelte-fzacrf"><label for="false-positive-rate" class="svelte-fzacrf">Target False Positive Rate (p):</label> <input id="false-positive-rate" type="number" min="0.000001" max="0.999999" step="0.001" placeholder="0.01" class="svelte-fzacrf"></div> <div class="mode-section svelte-fzacrf"><h4 class="svelte-fzacrf">Calculation Mode</h4> <div class="radio-group svelte-fzacrf"><label class="radio-label svelte-fzacrf"><input type="radio"> Calculate optimal parameters</label> <label class="radio-label svelte-fzacrf"><input type="radio"> Use custom parameters</label></div></div> <!></div> <div class="results-section svelte-fzacrf"><h3 class="svelte-fzacrf">Calculated Results</h3> <div class="results-grid svelte-fzacrf"><div class="result-card svelte-fzacrf"><div class="result-label svelte-fzacrf">Bit Array Size (m)</div> <div class="result-value svelte-fzacrf"> </div> <div class="result-unit svelte-fzacrf">bits</div></div> <div class="result-card svelte-fzacrf"><div class="result-label svelte-fzacrf">Hash Functions (k)</div> <div class="result-value svelte-fzacrf"> </div> <div class="result-unit svelte-fzacrf">functions</div></div> <div class="result-card svelte-fzacrf"><div class="result-label svelte-fzacrf">Actual False Positive Rate</div> <div class="result-value svelte-fzacrf"> </div> <div class="result-unit svelte-fzacrf">probability</div></div> <div class="result-card svelte-fzacrf"><div class="result-label svelte-fzacrf">Memory Usage</div> <div class="result-value svelte-fzacrf"> </div> <div class="result-unit svelte-fzacrf">total</div></div> <div class="result-card svelte-fzacrf"><div class="result-label svelte-fzacrf">Bits per Element</div> <div class="result-value svelte-fzacrf"> </div> <div class="result-unit svelte-fzacrf">bits/element</div></div> <div class="result-card svelte-fzacrf"><div class="result-label svelte-fzacrf">Space Efficiency</div> <div class="result-value svelte-fzacrf"> </div> <div class="result-unit svelte-fzacrf"></div></div></div></div></div> <div class="parameters-column svelte-fzacrf"><div class="parameters-section svelte-fzacrf"><h3 class="svelte-fzacrf">Current Parameters</h3> <div class="parameter-item svelte-fzacrf"><label class="svelte-fzacrf">Expected Elements (n):</label> <span class="parameter-value svelte-fzacrf"> </span></div> <div class="parameter-item svelte-fzacrf"><label class="svelte-fzacrf">Target FPR (p):</label> <span class="parameter-value svelte-fzacrf"> </span></div> <div class="parameter-item svelte-fzacrf"><label class="svelte-fzacrf">Bit Array Size (m):</label> <span class="parameter-value svelte-fzacrf"> </span></div> <div class="parameter-item svelte-fzacrf"><label class="svelte-fzacrf">Hash Functions (k):</label> <span class="parameter-value svelte-fzacrf"> </span></div></div> <div class="parameters-section svelte-fzacrf"><h3 class="svelte-fzacrf">Quick Presets</h3> <div class="preset-buttons svelte-fzacrf"><button class="preset-btn svelte-fzacrf">Small (1K, 1%)</button> <button class="preset-btn svelte-fzacrf">Medium (100K, 1%)</button> <button class="preset-btn svelte-fzacrf">Large (1M, 0.1%)</button></div></div></div></div></div>');function La(l,a){Qs(a,!0);const t=[],r=32;let o=F(1e5),d=F(.01),c=F(null),m=F(null),u=F("optimal");const p=I(()=>s(o)<=0||s(d)<=0||s(d)>=1?0:Math.ceil(-(s(o)*Math.log(s(d)))/Math.pow(Math.log(2),2))),k=I(()=>s(o)<=0||s(p)<=0?0:Math.max(1,Math.round(s(p)/s(o)*Math.log(2)))),w=I(()=>{const y=s(u)==="optimal"?s(p):s(c)||s(p),j=s(u)==="optimal"?s(k):s(m)||s(k),V=s(o);return V<=0||y<=0||j<=0?0:Math.pow(1-Math.exp(-j*V/y),j)}),_=I(()=>{const y=s(u)==="optimal"?s(p):s(c)||s(p);return Math.ceil(y/8)}),B=I(()=>{const y=s(u)==="optimal"?s(p):s(c)||s(p);return s(o)<=0?0:y/s(o)});function D(y,j=2){return y===0?"0":y<.01&&y>0?y.toExponential(2):y.toLocaleString(void 0,{maximumFractionDigits:j})}function M(y){return(y*100).toFixed(4)+"%"}function O(y){return y<1024?`${y} B`:y<1024*1024?`${(y/1024).toFixed(2)} KiB`:`${(y/(1024*1024)).toFixed(2)} MiB`}var T=Oa(),C=e(i(T),2),z=i(C),Z=i(z),L=e(i(Z),2),J=e(i(L),2);es(J),n(L);var P=e(L,2),$=e(i(P),2);es($),n(P);var R=e(P,2),ns=e(i(R),2),N=i(ns),W=i(N);es(W),W.value=W.__value="optimal",Q(),n(N);var U=e(N,2),S=i(U);es(S),S.value=S.__value="custom",Q(),n(U),n(ns),n(R);var Y=e(R,2);{var ss=y=>{var j=Ia(),V=i(j),xs=e(i(V),2);es(xs),n(V);var Hs=e(V,2),Es=e(i(Hs),2);es(Es),n(Hs),n(j),ts((as,Us)=>{ea(xs,"placeholder",as),ea(Es,"placeholder",Us)},[()=>s(p).toString(),()=>s(k).toString()]),Fs(xs,()=>s(c),as=>h(c,as)),Fs(Es,()=>s(m),as=>h(m,as)),H(y,j)};Ps(Y,y=>{s(u)==="custom"&&y(ss)})}n(Z);var is=e(Z,2),hs=e(i(is),2),ds=i(hs),us=e(i(ds),2),vs=i(us,!0);n(us),Q(2),n(ds);var ls=e(ds,2),Bs=e(i(ls),2),ys=i(Bs,!0);n(Bs),Q(2),n(ls);var fs=e(ls,2),zs=e(i(fs),2),Gs=i(zs,!0);n(zs),Q(2),n(fs);var rs=e(fs,2),Ds=e(i(rs),2),As=i(Ds,!0);n(Ds),Q(2),n(rs);var gs=e(rs,2),bs=e(i(gs),2),Ts=i(bs,!0);n(bs),Q(2),n(gs);var ks=e(gs,2),os=e(i(ks),2),ws=i(os);n(os);var Cs=e(os,2);Cs.textContent="vs naive storage (32 bits/element)",n(ks),n(hs),n(is),n(z);var Ms=e(z,2),ps=i(Ms),cs=e(i(ps),2),Ss=e(i(cs),2),v=i(Ss,!0);n(Ss),n(cs);var f=e(cs,2),b=e(i(f),2),g=i(b,!0);n(b),n(f);var A=e(f,2),G=e(i(A),2),ms=i(G,!0);n(G),n(A);var K=e(A,2),js=e(i(K),2),ma=i(js,!0);n(js),n(K),n(ps);var Zs=e(ps,2),Js=e(i(Zs),2),$s=i(Js);$s.__click=[qa,o,d,u];var sa=e($s,2);sa.__click=[Pa,o,d,u];var ha=e(sa,2);ha.__click=[Wa,o,d,u],n(Js),n(Zs),n(Ms),n(C),n(T),ts((y,j,V,xs,Hs,Es,as,Us)=>{E(vs,y),E(ys,s(u)==="optimal"?s(k):s(m)||s(k)),E(Gs,j),E(As,V),E(Ts,xs),E(ws,`${Hs??""}%`),E(v,Es),E(g,as),E(ms,Us),E(ma,s(u)==="optimal"?s(k):s(m)||s(k))},[()=>D(s(u)==="optimal"?s(p):s(c)||s(p),0),()=>M(s(w)),()=>O(s(_)),()=>D(s(B)),()=>D(100*(1-s(_)/(s(o)*r))),()=>D(s(o),0),()=>M(s(d)),()=>D(s(u)==="optimal"?s(p):s(c)||s(p),0)]),Fs(J,()=>s(o),y=>h(o,y)),Fs($,()=>s(d),y=>h(d,y)),ta(t,[],W,()=>s(u),y=>h(u,y)),ta(t,[],S,()=>s(u),y=>h(u,y)),H(l,T),Xs()}ra(["click"]);const ca={date:"2025-06-09",tags:["Algorithms"],keywords:["Bloom filters","Probabilistic data structures","Hash functions","Bit arrays"],title:"Grokking Bloom Filters - Part 1",preview:"How a tiny data structure cuts memory usage by 90% — while helping systems instantly check if data exists.",draft:!1,hero:"/images/blog/008-bloom-filters-pt1/hero.jpg"},{date:Za,tags:Ja,keywords:$a,title:se,preview:ae,draft:ee,hero:te}=ca;var Ra=q(`<p>There’s a special category of data structures known as probabilistic data structures — and I have a soft spot for some of them. One of my absolute favorites is the Bloom filter. It’s a beautifully simple concept that tackles a surprisingly common challenge: how can we quickly check whether something belongs to a set — without eating up loads of memory?</p> <p>Even though Bloom filters aren’t something most of us use directly in everyday business code, they quietly work behind the scenes in the infrastructure of modern distributed systems, databases, and web services.</p> <p>Instead of storing the actual data, Bloom filters use a clever combo of hash functions and bit arrays to give us lightning-fast answers to a very simple question: is this thing definitely not in the set — or is it maybe there?</p> <p>This post is a deep dive — it’s long, and we’ll take our time walking through how Bloom filters work, how they’re built, and how they behave. But if you’re just here to see it in action, feel free to jump straight to the <a href="#live-demo">interactive playground</a> and try it out yourself. Or, if you’re ready to tune your own Bloom filter, head over to the <a href="#play-with-the-numbers">calculator</a> to configure parameters for your use case.</p> <h2 id="contents"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#contents">#</a>Contents</h2> <ul><li><a href="#what-is-a-bloom-filter">What is a Bloom Filter?</a></li> <li><a href="#how-bloom-filters-work">How Bloom Filters Work</a> <ul><li><a href="#live-demo">Live Demo</a></li> <li><a href="#why-cant-we-delete">Why Can’t We Delete?</a></li> <li><a href="#can-it-scale">Can It Scale?</a></li></ul></li> <li><a href="#optimizing-hash-functions">Optimizing Hash Functions</a> <ul><li><a href="#double-hashing-approach">Double Hashing Approach</a></li> <li><a href="#wide-hash-split">Wide Hash Split</a></li> <li><a href="#recap">Recap</a></li></ul></li> <li><a href="#how-to-calculate-parameters">How to Calculate Parameters</a> <ul><li><a href="#the-false-positive-rate">The False Positive Rate</a></li> <li><a href="#how-parameters-affect-performance">How Parameters Affect Performance</a></li> <li><a href="#calculating-optimal-parameters">Calculating Optimal Parameters</a></li> <li><a href="#examples-with-calculations">Examples With Calculations</a></li> <li><a href="#play-with-the-numbers">Play With The Numbers</a></li></ul></li> <li><a href="#wrapping-up">Wrapping Up</a></li></ul> <h2 id="what-is-a-bloom-filter"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#what-is-a-bloom-filter">#</a>What is a Bloom Filter?</h2> <p>A Bloom filter is a space-efficient probabilistic data structure designed to test whether an element belongs to a set. The key insight behind Bloom filters is their fundamental trade-off: they can guarantee with absolute certainty that an element is <em>not</em> in the set, but when they report that an element <em>is</em> present, there’s a small chance this may be a false positive. This asymmetry makes them especially useful as a first-line filter in systems where false positives are acceptable, but false negatives are not.</p> <blockquote><p>If you’re not familiar with the terms <em>false positive</em> and <em>false negative</em>, here’s a quick translation:</p> <ul><li>A <strong>false positive</strong> means the system says “yes, it’s here” when actually it’s not.</li> <li>A <strong>false negative</strong> means the system says “no, it’s not here” when actually it is.</li></ul></blockquote> <p>The core idea is simple yet powerful. Rather than storing the actual elements, a Bloom filter keeps only hashed representations of the elements inside a compact bit array. This sacrifices some precision but delivers outstanding space efficiency and fast query times. For example, a typical Bloom filter with a 1% error rate requires just about 9.6 bits per element—regardless of the size of the elements themselves. That’s a significant improvement over traditional data structures like hash tables or hash sets, which must store the full data items.</p> <p>Bloom filters may report false positives — claiming an element is present when it isn’t — but they never report false negatives. This makes them extremely reliable for exclusion queries. This property has made Bloom filters invaluable in a wide range of applications, from web caching to database query optimization, where the cost of a false positive is far lower than the cost of missing a true member.</p> <h2 id="how-bloom-filters-work"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#how-bloom-filters-work">#</a>How Bloom Filters Work</h2> <p>The algorithm behind Bloom filters is elegantly built on three main components: a fixed-size bit array, multiple independent hash functions, and straightforward insertion and lookup operations. An empty Bloom filter starts as a bit array of <code>m</code> bits, all initialized to 0, and comes equipped with <code>k</code> different hash functions that map each element to exact <code>k</code> positions within the array. For optimal performance, these hash functions should ideally be independent and uniformly distributed.</p> <blockquote><p>A hash function is a function that takes an input (like a string or number) and deterministically maps it to a number within a fixed range — in this case, some positions in the bit array.<br> When we say that hash functions should be <strong>independent</strong>, we mean that knowing the output of one hash function doesn’t help you guess or calculate the output of another — each one works on its own, like rolling different dice.<br> And when we say they are <strong>uniformly distributed</strong>, we mean that they spread their results evenly across all possible positions, so no part of the resulting bit array gets overloaded with too many bits set.</p> <p>Examples of commonly used hash functions include MurmurHash, xxHash, CityHash, or cryptographic ones like SHA-256 (though cryptographic hashes are usually overkill for Bloom filters).</p></blockquote> <p>Inserting an element is fast and deterministic: the element is fed into each of the <code>k</code> hash functions, producing <code>k</code> unique array positions. The bits at all these positions are then set to 1. No matter how many elements have already been inserted, this operation always requires exactly <code>k</code> hash calculations and <code>k</code> bit updates. The beauty of this approach is its simplicity—there’s no need for collision resolution or complex data structures.</p> <p>Lookup works similarly. To check whether an element might be in the set, the algorithm runs the element through the same <code>k</code> hash functions to obtain <code>k</code> positions. If any of these bits is 0, the element is definitely not in the set — this is guaranteed, since insertion would have set all these bits to 1. However, if all the bits are 1, the element <em>might</em> be in the set, but there’s also a chance that these bits were set by previous insertions of other elements. This creates the possibility of a false positive.</p> <p>The math behind this comes from the probabilistic nature of hash collisions. As more elements are added, more bits get flipped to 1, which increases the chance that any random combination of <code>k</code> positions is already occupied, even for elements that were never inserted. That’s why the false positive rate grows with the number of elements, while the false negative rate stays at zero — if an element was inserted, it will always test as present.</p> <h3 id="live-demo"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#live-demo">#</a>Live Demo</h3> <p>Let’s get our hands dirty.</p> <p>In the interactive playground below, you can <strong>insert any string values into the Bloom filter</strong> and watch how it modifies the internal bit array. You can also <strong>check if a value is present</strong>, and see how Bloom filters may return <code>possibly present</code> even for things you never inserted — that’s our famous false positives in action.</p> <p>A few technical notes about this demo:</p> <ul><li>It uses a <strong>double hashing technique</strong> (which we’ll cover in more detail later). In short: instead of generating many completely separate hashes, it combines just two distinct hash functions to simulate any number of <code>k</code> hash functions. This approach is both efficient and widely used in real-world Bloom filters.</li> <li>For simplicity and to keep things visual, the filter here uses a very compact bit array — only <strong>16 bits</strong> (<code>m = 16</code>) and sets <code>k = 4</code> bit positions for each element.</li></ul> <p>Here’s what happens under the hood:</p> <ul><li>When you add a value: the filter applies the double hash to calculate <code>k</code> positions and flips the corresponding bits to <code>1</code>.</li> <li>When you check a value: it verifies if all these bits are still set to <code>1</code>. If yes — it says “maybe”; if any of them is <code>0</code> — it’s a definite “no”.</li></ul> <!> <h3 id="why-cant-we-delete"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#why-cant-we-delete">#</a>Why Can’t We Delete?</h3> <p>As you may have already noticed, we have <strong>INSERT</strong> and <strong>CHECK</strong> operations in Bloom filters, but I never mentioned a <strong>DELETE</strong> operation. That’s because — in the original design — we simply can’t. At least, not without breaking some of the guarantees that make Bloom filters useful in the first place. (Though, as we’ll see later in the series, there <em>are</em> variations of Bloom filters that support deletion.)</p> <p>The root of the problem is that multiple elements may hash to the same bit positions. When you attempt to delete an element by resetting its bits back to <code>0</code>, you risk clearing bits that may still be in use by other elements. Since Bloom filters are designed to avoid <strong>false negatives</strong>, any operation that might accidentally remove evidence of another element’s presence would break this guarantee.</p> <p>As one researcher <a href="https://www.math.umd.edu/~immortal/CMSC420/notes/bloomfilters.pdf" rel="nofollow">puts it nicely:</a>:</p> <blockquote><p>“There is no deletion basically because the only reasonable way to delete would be to hash the key and then set those corresponding bits to 0, but this could cause false negatives for other keys.”</p></blockquote> <p>Let’s visualize this. Imagine a Bloom filter as a shared apartment building where multiple tenants (elements) occupy overlapping rooms (bit positions).</p> <ul><li>When Alice moves in, she gets keys to rooms <code>3</code>, <code>7</code>, and <code>12</code>.</li> <li>When Bob moves in, he gets keys to rooms <code>7</code>, <code>15</code>, and <code>23</code>.</li></ul> <p>Notice: both Alice and Bob share room <code>7</code>.</p> <p>Now, if Alice moves out and we naively “delete” her by switching off the lights (setting bits to <code>0</code>) in rooms <code>3</code>, <code>7</code>, and <code>12</code>, we inadvertently turn off room <code>7</code>, which Bob still needs.<br> The next time someone asks, “Is Bob still living here?”, the system might falsely answer “No” — even though Bob never left. That’s a <strong>false negative</strong>, and Bloom filters are designed specifically to prevent that.</p> <p>Of course, for a quick and dirty workaround, an engineer might introduce a second “blacklist” Bloom filter to track deletions. When checking membership, an element would only be considered present if it’s in the main filter <strong>and</strong> not in the deletion filter. But this comes with its own trade-offs — and we’ll cover better solutions later.</p> <h3 id="can-it-scale"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#can-it-scale">#</a>Can It Scale?</h3> <p>The second major limitation of standard Bloom filters is their <strong>fixed size</strong>. Once you create a Bloom filter, you can’t resize it on the fly without breaking its mathematical guarantees.</p> <p>Traditional Bloom filters require you to <strong>declare their size upfront</strong> — it’s a bit like booking an apartment based on how many guests you <em>think</em> might show up. This creates the classic “Goldilocks problem”:</p> <ul><li><strong>Underestimated capacity</strong>: You planned for 1M elements but end up with 1.2M? The false positive rate can shoot up to 20% or even higher.</li> <li><strong>Overestimated capacity</strong>: You reserved space for 10M elements but only store 1M? You’re wasting 90% of your allocated memory.</li></ul> <p>The <a href="https://gsd.di.uminho.pt/members/cbm/ps/dbloom.pdf" rel="nofollow">solution</a> — or rather, the workaround — is fairly straightforward: monitor the Bloom filter’s saturation. Once the false positive rate crosses an unacceptable threshold, you simply add another (larger) Bloom filter. To check membership, you query all filters in sequence until you get a match or exhaust them.</p> <h2 id="optimizing-hash-functions"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#optimizing-hash-functions">#</a>Optimizing Hash Functions</h2> <p>As we discussed earlier, the key to an efficient Bloom filter lies in having k independent and uniformly distributed hash functions. The more evenly they spread their outputs across the bit array, the lower the risk of false positives.</p> <p>While this idea is elegant in theory, it’s more complicated in practice — creating and computing many truly independent hash functions can be both conceptually challenging and computationally expensive.</p> <p>Designing good hash functions isn’t something most engineers do every day. Creating a brand new hash function that minimizes collisions and evenly spreads values across the bit array is far from trivial. And Bloom filters typically require at least two hash functions — sometimes even four or more depending on your workload and the nature of the data you’re adding.</p> <p>As you probably noticed in your day-to-day work, we rarely write our own math-heavy algorithms from scratch. Instead, we lean on solid, battle-tested abstractions: hashing libraries, built-in data structures, utility modules, etc. Even if you’re adventurous enough to roll out your own Bloom filter implementation, you probably don’t want to spend weeks designing hash functions from scratch — but you still want decent performance.</p> <p>On top of that, hash computation itself can get expensive, especially if you’re using cryptographic hashes like SHA-256. These functions are overkill for Bloom filters and introduce unnecessary overhead. Faster non-cryptographic hash functions like <strong>MurmurHash</strong> or <strong>xxHash</strong> are much better suited for this use case — but even then, if you naively calculate <em>k</em> separate hashes per element, the cost adds up.</p> <p>Let’s take a look at a simple, naive approach just to set the baseline:</p> <!> <p>At first glance, problem solved: you’re generating multiple hash values by salting your input with different constants. It works, and it’s easy to implement. But this method has an important drawback — you need to compute <em>k</em> separate hashes for every element, which becomes costly for larger <em>k</em> values (say 10 or more) — especially if the hash function itself isn’t cheap.</p> <p>While this approach might be acceptable for use-cases where performance isn’t important, let’s be honest: for such cases, you probably don’t even need a Bloom filter — a plain old <code>Set</code> would do the job just fine.</p> <h3 id="double-hashing-approach"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#double-hashing-approach">#</a>Double Hashing Approach</h3> <p>Luckily, there’s a well-known trick to avoid computing <em>k</em> independent hash functions while still achieving almost the same statistical behavior. This method is often called <strong>double hashing</strong> or <strong>Kirsch-Mitzenmacher optimization</strong>, after the authors who <a href="https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf" rel="nofollow">formally analyzed it</a>.</p> <p>The idea is surprisingly simple: instead of calculating <em>k</em> totally independent hashes, you calculate just two independent hash functions, and then combine them to generate the rest.</p> <p>The formula goes like this:</p> <div class="math math-display"><!></div> <p>Where:</p> <ul><li><code>h1(x)</code> and <code>h2(x)</code> are two independent hash functions (or at least two reasonably uncorrelated ones).</li> <li><code>i</code> is the index of the hash function you want (ranging from 0 to k-1).</li> <li>Each resulting value is then typically reduced by modulo <code>m</code> (the bit array size) to map it into the bit array in case it’s larger than the bit array size.</li></ul> <p>In code, it may look something like this:</p> <!> <p>This approach has several nice properties:</p> <ul><li>You only calculate <strong>two</strong> hash functions per inserted element, no matter how many hash functions <em>k</em> you want.</li> <li>You get a whole sequence of hash values that are nicely spread across your bit array.</li> <li>The results are nearly as good as having fully independent hashes, at least for practical Bloom filter usage.</li></ul> <h4 id="why-does-double-hashing-work"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#why-does-double-hashing-work">#</a>Why does Double-Hashing Work?</h4> <p>Without diving too deep into math: Kirsch and Mitzenmacher showed that this sequence of hashes behaves <em>almost</em> like having <em>k</em> independent hashes for the purposes of a Bloom filter. The false-positive rate remains essentially the same, while computational cost is dramatically reduced.</p> <p>This optimization is commonly used in real-world Bloom filter implementations — for example, it’s part of <a href="https://github.com/apache/cassandra/blob/trunk/src/java/org/apache/cassandra/utils/BloomFilter.java" rel="nofollow">Cassandra’s BloomFilter implementation</a>.</p> <h4 id="but-what-if-h2-is-zero"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#but-what-if-h2-is-zero">#</a>But what if <code>h2</code> is zero?</h4> <p>Yeah… You may have already noticed a potential issue in our formula:</p> <div class="math math-display"><!></div> <p>If <code>h2(x)</code> happens to be zero, all your hashes collapse into the same value:</p> <div class="math math-display"><!></div> <p>How likely is that? Well, it depends, but not impossible.</p> <p>To protect yourself, many implementations include a tiny fix like:</p> <!> <p>This guarantees forward progress: even in the worst case you still generate <code>k</code> distinct bit positions.</p> <h4 id="h2x-and-m-should-be-coprime"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#h2x-and-m-should-be-coprime">#</a><code>h2(x)</code> and <code>m</code> Should Be Coprime</h4> <p>There’s one more sneaky issue that’s often overlooked when using the double hashing formula:</p> <div class="math math-display"><!></div> <p>Everything seems fine… until one day your Bloom filter quietly becomes <em>less random than you expect</em>. This happens when <code>h2(x)</code> and <code>m</code> (the Bloom filter size) are not <strong>coprime</strong>.</p> <blockquote><p><strong>What does “coprime” mean?</strong> Two numbers are coprime if they don’t share any common divisors except 1.
For example:</p> <ul><li><code>9</code> and <code>16</code> are coprime.</li> <li><code>6</code> and <code>18</code> are <strong>not</strong> coprime (since they share divisor <code>6</code>).</li></ul></blockquote> <p>If <code>h2(x)</code> and <code>m</code> share a common divisor, the sequence of hashes generated</p> <!> <p>will only cover part of the bit array. In other words: <strong>you won’t reach all possible bit positions</strong>.</p> <p>This leads to: fewer unique bits set → more collisions → higher false-positive rates → sad stakeholders.</p> <p>Let’s say you have:</p> <ul><li><code>m = 10</code></li> <li><code>h1(x) = 2</code></li> <li><code>h2(x) = 4</code> (notice that both <code>4</code> and <code>10</code> share divisor <code>2</code>)</li></ul> <p>Now calculate the hashes:</p> <!> <p>You never touch bit positions <code>1, 3, 5, 7, 9</code> — half of your bit array is completely unused!</p> <p>Ideally, choose <code>m</code> to be a <strong>prime number</strong> — then any <code>h2(x)</code> is automatically coprime with <code>m</code> (except if <code>h2(x) = 0</code> which we already handled earlier).</p> <p>Or, when <code>m</code> is not prime, ensure that your hash function produces <code>h2(x)</code> values that are statistically unlikely to share factors with <code>m</code>. A simple safety net is to force <code>h2(x)</code> to always be odd:</p> <!> <p>This avoids most practical problems if <code>m</code> is a power of two (which is very common for bit arrays).</p> <p>Let’s walk through a small example where things work exactly as intended:</p> <ul><li><code>m = 10</code></li> <li><code>h1(x) = 2</code></li> <li><code>h2(x) = 7</code> (notice that <code>7</code> and <code>10</code> are coprime (they share no divisors except <code>1</code>)</li></ul> <p>Hash values be like that:</p> <!> <p>Full cycle, no repeats — the bit array is fully covered.</p> <h3 id="wide-hash-split"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#wide-hash-split">#</a>Wide Hash Split</h3> <p>There’s another technique that sometimes gets used, especially in high-performance Bloom filters - wide hash split. A good example is <a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/BloomFilterStrategies.java" rel="nofollow">Google Guava</a>, where it works nicely alongside the double hashing approach.</p> <p>The core idea is also simple - instead of generating multiple completely separate hash values, you generate <strong>one wide hash output</strong> (e.g. 128 or 256 bits), and then split it into multiple pieces to simulate multiple hash functions.</p> <!> <h4 id="why-does-hash-split-work"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#why-does-hash-split-work">#</a>Why does hash split work?</h4> <p>Good hash functions like <strong>MurmurHash3 128-bit</strong>, <strong>CityHash128</strong>, or <strong>xxHash3 128-bit</strong> are designed to spread randomness across all bits, i.e. have avalanche effect, when small input changes drastically alter all output bits. So, the upper bits are just as random as the lower bits.</p> <p>Of course, like everything in Bloom filters — no free lunch:</p> <ul><li>The resulting hashes are <strong>not truly independent</strong>, just decorrelated, i.e. different enough. This may theoretically increase false positives slightly if your input data is highly correlated and the hash function doesn’t have good avalanche effect.</li> <li>You’re limited by how many slices you can get — e.g., 128-bit hash gives you at most 4×32-bit slices (or more if you slice into smaller chunks).</li></ul> <h3 id="recap"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#recap">#</a>Recap</h3> <table><thead><tr><th>Method</th><th># of Hash Calls</th><th>Speed</th><th>Independence</th></tr></thead><tbody><tr><td>k hashes</td><td>k</td><td>Slow</td><td>True</td></tr><tr><td>Double hashing</td><td>2</td><td>Fast</td><td>Almost</td></tr><tr><td>Wide hash split</td><td>1</td><td>Even faster</td><td>Almost</td></tr></tbody></table> <h2 id="how-to-calculate-parameters"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#how-to-calculate-parameters">#</a>How to Calculate Parameters</h2> <p>Strictly speaking, this section should be at the very beginning — but I didn’t want to scare you away with formulas too early. Since you’re still here, let’s finally dive into how to properly configure your Bloom filter.</p> <p>Some of the parameters you’ve already met, but let’s quickly recap:</p> <ol><li><strong>m</strong> — the size of the bit array (in bits)</li> <li><strong>n</strong> — the expected number of inserted elements</li> <li><strong>k</strong> — the number of hash functions and bit positions to set</li> <li><strong>p</strong> — the false positive probability (also called <strong>FPP</strong>)</li></ol> <p>These parameters are tightly interconnected — changing one affects the others, leading to trade-offs between memory usage, query speed, and accuracy.</p> <h3 id="the-false-positive-rate"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#the-false-positive-rate">#</a>The False Positive Rate</h3> <p>The false positive rate is arguably the most important characteristic of a Bloom filter. It represents the probability that the filter incorrectly reports an element as present when it actually isn’t. The theoretical false positive probability can be approximated by:</p> <div class="math math-display"><!></div> <p>Where once again:</p> <ul><li><code>p</code> is the false positive probability</li> <li><code>k</code> is the number of hash functions and bit positions to set</li> <li><code>n</code> is the number of inserted elements</li> <li><code>m</code> is the size of the bit array</li></ul> <blockquote><p>It’s worth noting that this formula is an approximation. According to <a href="https://cglab.ca/~morin/publications/ds/bloom-submitted.pdf" rel="nofollow">detailed mathematical analysis</a>, the actual false positive rate is strictly larger than this approximation for any k ≥ 2.</p></blockquote> <h3 id="how-parameters-affect-performance"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#how-parameters-affect-performance">#</a>How Parameters Affect Performance</h3> <h4 id="memory-usage"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#memory-usage">#</a>Memory Usage</h4> <p>The memory usage of a Bloom filter is directly proportional to <code>m</code>. This is one of its key strengths — excellent space efficiency compared to hash tables or sets.</p> <p>For <a href="https://valkey.io/blog/introducing-bloom-filters/" rel="nofollow">example</a>, let’s say you want to maintain 500 Bloom filters, each capable of holding 5 million elements. The total memory depends heavily on your target false positive rate:</p> <table><thead><tr><th>False Positive Rate</th><th>Total Memory</th><th>Memory Savings vs SET</th></tr></thead><tbody><tr><td>0.01 (1 in 100)</td><td>2.9 GB</td><td>98.08% saved</td></tr><tr><td>0.001 (1 in 1,000)</td><td>4.9 GB</td><td>96.80% saved</td></tr><tr><td>0.00001 (1 in 100,000)</td><td>7.8 GB</td><td>94.88% saved</td></tr></tbody></table> <h4 id="query-performance"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#query-performance">#</a>Query Performance</h4> <p>Both insertions and lookups require computing <code>k</code> hash functions and updating or reading <code>k</code> bits. Therefore, both operations have time complexity <code>O(k)</code>, assuming that hash function is some constant time operation. Since <code>k</code> is typically small (usually between 5 and 12), Bloom filters are extremely fast for membership checks, regardless of how many elements they contain.</p> <h3 id="calculating-optimal-parameters"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#calculating-optimal-parameters">#</a>Calculating Optimal Parameters</h3> <h4 id="optimal-size-m"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#optimal-size-m">#</a>Optimal Size (m)</h4> <p>If you know the expected number of elements (<code>n</code>) and your target false positive probability (<code>p</code>), you can compute the optimal size of the bit array as:</p> <div class="math math-display"><!></div> <p>Or approximately:</p> <div class="math math-display"><!></div> <h4 id="optimal-number-of-hash-functions-k"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#optimal-number-of-hash-functions-k">#</a>Optimal Number of Hash Functions (k)</h4> <p>Once you have <code>m</code>, you can compute the optimal number of hash functions:</p> <div class="math math-display"><!></div> <p>Or approximately:</p> <div class="math math-display"><!></div> <p>Choosing this optimal <code>k</code> minimizes the false positive rate for your selected <code>m</code> and <code>n</code>.</p> <h3 id="examples-with-calculations"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#examples-with-calculations">#</a>Examples With Calculations</h3> <h4 id="example-1-calculating-size-and-hash-functions"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#example-1-calculating-size-and-hash-functions">#</a>Example 1: Calculating Size and Hash Functions</h4> <p>Given:</p> <ul><li><code>n = 100,000</code> (expected elements)</li> <li><code>p = 0.01</code> (1% false positive rate)</li></ul> <p>Calculate <code>m</code>:</p> <!> <p>Calculate <code>k</code>:</p> <!> <h4 id="example-2-calculating-false-positive-rate"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#example-2-calculating-false-positive-rate">#</a>Example 2: Calculating False Positive Rate</h4> <p>Given:</p> <ul><li><code>n = 100</code> (elements)</li> <li><code>m = 1,000</code> (bits)</li> <li><code>k = 4</code> (hash functions)</li></ul> <p>Calculate <code>p</code>:</p> <!> <p>So the false positive rate is approximately <strong>1.18%</strong>.</p> <h3 id="play-with-the-numbers"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#play-with-the-numbers">#</a>Play With The Numbers</h3> <p>If you’re getting bored (or dizzy) with all these formulas — don’t worry. Instead of torturing your brain, let’s just throw your numbers into the calculator below and let it crunch everything for you.</p> <p>After all, you’re sitting right next to one of the most advanced calculators humanity ever built — <strong>for Christ’s sake, let it do the math.</strong></p> <!> <h2 id="wrapping-up"><a class="header-anchor" aria-hidden="true" tabindex="-1" href="#wrapping-up">#</a>Wrapping Up</h2> <p>Every time I revisit Bloom filters, I’m reminded why computer science so often feels like magic. A simple structure — just a bit array and a handful of hash functions — yet it dances gracefully with probability to solve problems that could easily swallow gigabytes of memory if approached naively.</p> <p>And yet — this is only the beginning.</p> <p>As we move forward, we’ll see how this beautifully simple idea can be stretched, twisted, and extended to take on even bigger challenges.</p> <p>See you in the next parts — things are about to get even more interesting.</p>`,1);function Na(l){var a=Ra(),t=e(ka(a),48);Ha(t,{});var r=e(t,46);x(r,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> h1 </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#82AAFF;--shiki-dark:#B392F0"> hash_function_1</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">(</span><span style="color:#C792EA;--shiki-dark:#F97583">data</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> h2 </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#82AAFF;--shiki-dark:#B392F0"> hash_function_2</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">(</span><span style="color:#C792EA;--shiki-dark:#F97583">data</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">..</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">.</span></span>
<span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> hk </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#82AAFF;--shiki-dark:#B392F0"> hash_function_k</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">(</span><span style="color:#C792EA;--shiki-dark:#F97583">data</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">)</span></span></code></pre>`);var o=e(r,14),d=i(o);x(d,()=>'<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>position</mtext><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>⋅</mo><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">\\text{position}_i(x) = (h_1(x) + i \\cdot h_2(x)) \\bmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">position</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2175em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>'),n(o);var c=e(o,8);x(c,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> h1 </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#82AAFF;--shiki-dark:#B392F0"> hash1</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">(</span><span style="color:#C792EA;--shiki-dark:#F97583">data</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> h2 </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#82AAFF;--shiki-dark:#B392F0"> hash2</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">(</span><span style="color:#C792EA;--shiki-dark:#F97583">data</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;--shiki-dark:#F97583;--shiki-dark-font-style:inherit">for</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> (i </span><span style="color:#89DDFF;--shiki-dark:#F97583">in</span><span style="color:#F78C6C;--shiki-dark:#79B8FF"> 0</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> until k) &#123;</span></span>
<span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">    val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> position </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> (h1 </span><span style="color:#89DDFF;--shiki-dark:#F97583">+</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> i </span><span style="color:#89DDFF;--shiki-dark:#F97583">*</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> h2) </span><span style="color:#89DDFF;--shiki-dark:#F97583">%</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> m</span></span>
<span class="line"><span style="color:#82AAFF;--shiki-dark:#B392F0">    setBit</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">(position)</span></span>
<span class="line"><span style="color:#BABED8;--shiki-dark:#E1E4E8">&#125;</span></span>
<span class="line"></span></code></pre>`);var m=e(c,16),u=i(m);x(u,()=>'<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>position</mtext><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>⋅</mo><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">\\text{position}_i(x) = (h_1(x) + i \\cdot h_2(x)) \\bmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">position</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2175em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>'),n(m);var p=e(m,4),k=i(p);x(k,()=>'<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>position</mtext><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>⋅</mo><mn>0</mn><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>m</mi><mo>=</mo><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">\\text{position}_i(x) = (h_1(x) + i \\cdot 0) \\bmod m = h_1(x) \\bmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">position</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2175em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>'),n(p);var w=e(p,6);x(w,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;--shiki-dark:#F97583;--shiki-dark-font-style:inherit">if</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> (h2 </span><span style="color:#89DDFF;--shiki-dark:#F97583">==</span><span style="color:#F78C6C;--shiki-dark:#79B8FF"> 0</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">) &#123;</span></span>
<span class="line"><span style="color:#BABED8;--shiki-dark:#E1E4E8">    h2 </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#F78C6C;--shiki-dark:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#BABED8;--shiki-dark:#E1E4E8">&#125;</span></span></code></pre>`);var _=e(w,8),B=i(_);x(B,()=>'<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>position</mtext><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>⋅</mo><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">\\text{position}_i(x) = (h_1(x) + i \\cdot h_2(x)) \\bmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">position</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2175em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>'),n(_);var D=e(_,8);x(D,()=>'<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span>h1(x), h1(x) + h2(x), h1(x) + 2*h2(x), ...</span></span></code></pre>');var M=e(D,12);x(M,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span>(2 + 0*4) % 10 → 2  </span></span>
<span class="line"><span>(2 + 1*4) % 10 → 6  </span></span>
<span class="line"><span>(2 + 2*4) % 10 → 0  </span></span>
<span class="line"><span>(2 + 3*4) % 10 → 4  </span></span>
<span class="line"><span>(2 + 4*4) % 10 → 8  </span></span>
<span class="line"><span>(2 + 5*4) % 10 → 2  (cycle repeats)</span></span></code></pre>`);var O=e(M,8);x(O,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;--shiki-dark:#F97583;--shiki-dark-font-style:inherit">if</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> (h2 </span><span style="color:#89DDFF;--shiki-dark:#F97583">%</span><span style="color:#F78C6C;--shiki-dark:#79B8FF"> 2</span><span style="color:#89DDFF;--shiki-dark:#F97583"> ==</span><span style="color:#F78C6C;--shiki-dark:#79B8FF"> 0</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">) &#123;</span></span>
<span class="line"><span style="color:#BABED8;--shiki-dark:#E1E4E8">    h2 </span><span style="color:#89DDFF;--shiki-dark:#F97583">+=</span><span style="color:#F78C6C;--shiki-dark:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#BABED8;--shiki-dark:#E1E4E8">&#125;</span></span></code></pre>`);var T=e(O,10);x(T,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span>(2 + 0*7) % 10 → 2  </span></span>
<span class="line"><span>(2 + 1*7) % 10 → 9  </span></span>
<span class="line"><span>(2 + 2*7) % 10 → 6  </span></span>
<span class="line"><span>(2 + 3*7) % 10 → 3  </span></span>
<span class="line"><span>(2 + 4*7) % 10 → 0  </span></span>
<span class="line"><span>(2 + 5*7) % 10 → 7  </span></span>
<span class="line"><span>(2 + 6*7) % 10 → 4  </span></span>
<span class="line"><span>(2 + 7*7) % 10 → 1  </span></span>
<span class="line"><span>(2 + 8*7) % 10 → 8  </span></span>
<span class="line"><span>(2 + 9*7) % 10 → 5</span></span></code></pre>`);var C=e(T,10);x(C,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> wideHash </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#82AAFF;--shiki-dark:#B392F0"> hash128</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">(</span><span style="color:#C792EA;--shiki-dark:#F97583">data</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> h1 </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> (wideHash shr </span><span style="color:#F78C6C;--shiki-dark:#79B8FF">0</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">)  </span><span style="color:#89DDFF;--shiki-dark:#F97583">%</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> m </span><span style="color:#676E95;font-style:italic;--shiki-dark:#6A737D;--shiki-dark-font-style:inherit">// or apply mask, if m is a power of two</span></span>
<span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> h2 </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> (wideHash shr </span><span style="color:#F78C6C;--shiki-dark:#79B8FF">16</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">) </span><span style="color:#89DDFF;--shiki-dark:#F97583">%</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> m</span></span>
<span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> h3 </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> (wideHash shr </span><span style="color:#F78C6C;--shiki-dark:#79B8FF">32</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">) </span><span style="color:#89DDFF;--shiki-dark:#F97583">%</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> m</span></span>
<span class="line"><span style="color:#89DDFF;--shiki-dark:#F97583">val</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> h4 </span><span style="color:#89DDFF;--shiki-dark:#F97583">=</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> (wideHash shr </span><span style="color:#F78C6C;--shiki-dark:#79B8FF">48</span><span style="color:#BABED8;--shiki-dark:#E1E4E8">) </span><span style="color:#89DDFF;--shiki-dark:#F97583">%</span><span style="color:#BABED8;--shiki-dark:#E1E4E8"> m</span></span></code></pre>`);var z=e(C,28),Z=i(z);x(Z,()=>'<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo>=</mo><msup><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>k</mi><mi>n</mi><mi mathvariant="normal">/</mi><mi>m</mi></mrow></msup><mo fence="true">)</mo></mrow><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">p = \\left(1 - e^{-kn/m}\\right)^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.039em;vertical-align:-0.65em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">kn</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.389em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>'),n(z);var L=e(z,28),J=i(L);x(J,()=>'<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mi>ln</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>ln</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">m = -\\frac{n \\ln(p)}{(\\ln(2))^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mop">ln</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ln</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>'),n(L);var P=e(L,4),$=i(P);x($,()=>'<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>≈</mo><mo>−</mo><mi>n</mi><mi>ln</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>⋅</mo><mn>2.08</mn></mrow><annotation encoding="application/x-tex">m \\approx -n \\ln(p) \\cdot 2.08</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ln</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.08</span></span></span></span></span>'),n(P);var R=e(P,6),ns=i(R);x(ns,()=>'<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mi>ln</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k = \\frac{m}{n} \\ln(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ln</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span>'),n(R);var N=e(R,4),W=i(N);x(W,()=>'<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>≈</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>⋅</mo><mn>0.693</mn></mrow><annotation encoding="application/x-tex">k \\approx \\frac{m}{n} \\cdot 0.693</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.693</span></span></span></span></span>'),n(N);var U=e(N,14);x(U,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span>m = -(n * ln(p)) / (ln(2))^2</span></span>
<span class="line"><span>  = -(100,000 * ln(0.01)) / (ln(2))^2</span></span>
<span class="line"><span>  = -(100,000 * (-4.6052)) / (0.4809)</span></span>
<span class="line"><span>  ≈ 958,506 bits (≈ 117 KiB)</span></span></code></pre>`);var S=e(U,4);x(S,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span>k = (m / n) * ln(2)</span></span>
<span class="line"><span>  = (958,506 / 100,000) * 0.693</span></span>
<span class="line"><span>  ≈ 6.64 (≈ 7 hash functions)</span></span></code></pre>`);var Y=e(S,10);x(Y,()=>`<pre class="shiki shiki-themes material-theme-palenight github-dark" style="background-color:#292D3E;--shiki-dark-bg:#24292e;color:#babed8;--shiki-dark:#e1e4e8" tabindex="0"><code><span class="line"><span>p = (1 - e^(-k * n / m))^k</span></span>
<span class="line"><span>  = (1 - e^(-4 * 100 / 1000))^4</span></span>
<span class="line"><span>  = (1 - e^(-0.4))^4</span></span>
<span class="line"><span>  = (1 - 0.6703)^4</span></span>
<span class="line"><span>  = (0.3297)^4</span></span>
<span class="line"><span>  ≈ 0.0118</span></span></code></pre>`);var ss=e(Y,10);La(ss,{}),Q(10),H(l,a)}const ne=Object.freeze(Object.defineProperty({__proto__:null,default:Na,metadata:ca},Symbol.toStringTag,{value:"Module"}));export{ne as _};
